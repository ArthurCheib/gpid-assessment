[
  {
    "objectID": "simulated_data.html",
    "href": "simulated_data.html",
    "title": "Simulated Data",
    "section": "",
    "text": "## Loading the data we will be working with: simulated household surveys\nwdi_file &lt;- 'svy_sim_in1.Rds'\nwdi_household &lt;- get_data(rds_file = wdi_file)\n\n## Estimating the poverty measures\nyears &lt;- names(wdi_household)\npv_lines &lt;- c(2.15, 3.65, 6.85)\n\npoverty_measures &lt;- tibble()\n\n## Nested loop to compute the values for all combinations of years vs. poverty lines\nfor (table in years) {\n  \n  temp_results &lt;- tibble()\n  \n  ## For every poverty line ...\n  for (pv_line in pv_lines) {\n    \n    ## ... In a given year: compute FGT + bind_row the results\n    temp_data &lt;- FGT_calculator(survey_data = wdi_household[table],\n                                year = table,\n                                poverty_line = pv_line)\n    \n    temp_results &lt;- temp_results |&gt; \n      bind_rows(temp_data)\n    \n  }\n  \n  poverty_measures &lt;- poverty_measures |&gt; \n    bind_rows(temp_results)\n  \n}\n\n## Displaying the table\ndatatable(poverty_measures, options = list(pageLength = 10))\n\n\n\n\n\n## Replicating the graph (tried to make exactly as shown - no titles, subtitles, caption...)\npoverty_measures |&gt; \n  ggplot(aes(x = year, y = headcount, color = as.character(pov_line))) +\n  geom_point() +\n  geom_line(aes(group = pov_line)) +\n  theme_minimal() +\n  labs(color = '') +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\n## Transforming the data into long format\nlong_household &lt;- map_df(names(wdi_household), ~survey_long(.x, wdi_household[[.x]]))\n\n## Computing the Lorenz's variables\nlorenz_curve &lt;- df_lorenz(x = long_household, level = 1000)\n\n## Displaying the table\ndatatable(lorenz_curve, options = list(pageLength = 10))\n\n\n\n\n\n## Replicating the graph\nlorenz_curve |&gt; \n  ggplot(aes(x = cum_population, y = cum_welfare, color = as.factor(year), group = year)) +\n  geom_line() + \n  geom_abline(linetype = \"dashed\", color = \"red\") +\n  labs(color = \"\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") \n\n\n\n\n\n\n\n\n## Computing the gini\ngini_list &lt;- map(names(wdi_household), ~gini_calculator(wdi_household[[.x]]))\ngini_coefficient &lt;- tibble(year = c(2001:2010),\n                           gini = unlist(gini_list))\n\n## Displaying the table\ndatatable(gini_coefficient, options = list(pageLength = 10))\n\n\n\n\n\n## Plotting gini (again, keeping the exac same aesthetic)\ngini_coefficient |&gt; \n  ggplot(aes(x = year, y = gini)) +\n  geom_line(color = 'darkblue') +\n  geom_point() +\n  theme_minimal()"
  },
  {
    "objectID": "simulated_data.html#simulated-data",
    "href": "simulated_data.html#simulated-data",
    "title": "Simulated Data",
    "section": "",
    "text": "## Loading the data we will be working with: simulated household surveys\nwdi_file &lt;- 'svy_sim_in1.Rds'\nwdi_household &lt;- get_data(rds_file = wdi_file)\n\n## Estimating the poverty measures\nyears &lt;- names(wdi_household)\npv_lines &lt;- c(2.15, 3.65, 6.85)\n\npoverty_measures &lt;- tibble()\n\n## Nested loop to compute the values for all combinations of years vs. poverty lines\nfor (table in years) {\n  \n  temp_results &lt;- tibble()\n  \n  ## For every poverty line ...\n  for (pv_line in pv_lines) {\n    \n    ## ... In a given year: compute FGT + bind_row the results\n    temp_data &lt;- FGT_calculator(survey_data = wdi_household[table],\n                                year = table,\n                                poverty_line = pv_line)\n    \n    temp_results &lt;- temp_results |&gt; \n      bind_rows(temp_data)\n    \n  }\n  \n  poverty_measures &lt;- poverty_measures |&gt; \n    bind_rows(temp_results)\n  \n}\n\n## Displaying the table\ndatatable(poverty_measures, options = list(pageLength = 10))\n\n\n\n\n\n## Replicating the graph (tried to make exactly as shown - no titles, subtitles, caption...)\npoverty_measures |&gt; \n  ggplot(aes(x = year, y = headcount, color = as.character(pov_line))) +\n  geom_point() +\n  geom_line(aes(group = pov_line)) +\n  theme_minimal() +\n  labs(color = '') +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\n\n## Transforming the data into long format\nlong_household &lt;- map_df(names(wdi_household), ~survey_long(.x, wdi_household[[.x]]))\n\n## Computing the Lorenz's variables\nlorenz_curve &lt;- df_lorenz(x = long_household, level = 1000)\n\n## Displaying the table\ndatatable(lorenz_curve, options = list(pageLength = 10))\n\n\n\n\n\n## Replicating the graph\nlorenz_curve |&gt; \n  ggplot(aes(x = cum_population, y = cum_welfare, color = as.factor(year), group = year)) +\n  geom_line() + \n  geom_abline(linetype = \"dashed\", color = \"red\") +\n  labs(color = \"\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\") \n\n\n\n\n\n\n\n\n## Computing the gini\ngini_list &lt;- map(names(wdi_household), ~gini_calculator(wdi_household[[.x]]))\ngini_coefficient &lt;- tibble(year = c(2001:2010),\n                           gini = unlist(gini_list))\n\n## Displaying the table\ndatatable(gini_coefficient, options = list(pageLength = 10))\n\n\n\n\n\n## Plotting gini (again, keeping the exac same aesthetic)\ngini_coefficient |&gt; \n  ggplot(aes(x = year, y = gini)) +\n  geom_line(color = 'darkblue') +\n  geom_point() +\n  theme_minimal()"
  },
  {
    "objectID": "basic_stats.html",
    "href": "basic_stats.html",
    "title": "Basic Stats",
    "section": "",
    "text": "Computing summary statistics of the World Development Indicators (WDI) dataset, ‘wdi_data’, which contains socio-economic metrics for various countries over time (in years).\n\n## Loading the data to be computed\nwdi_file &lt;- 'wdi_in1.Rds'\nwdi_data &lt;- get_data(rds_file = wdi_file)\n\n## Data to be replicated\ndesired_output1 &lt;- get_data(rds_file = 'wdi_summ_out.Rds') |&gt; \n  arrange(region, year, N, Mean) |&gt; \n  as.data.frame()\n  \n## Replicating GDP per capita by region\nwdi_summary_gdp &lt;- wdi_data |&gt; \n  mutate(year = as.character(date)) |&gt; \n  select(region, iso3c, year, everything(), -date) |&gt; \n  filter(!is.na(gdp)) |&gt; \n  group_by(region, year) |&gt; \n  summarize(N = as.double(n()),\n            Mean = weighted.mean(gdp, pop, na.rm = TRUE),\n            SD = weighted_sd(gdp, pop, na.rm = TRUE),\n            Min = min(gdp, na.rm = TRUE),\n            Max = max(gdp, na.rm = TRUE)) |&gt; \n  ungroup() |&gt;\n  arrange(region, year, N, Mean) |&gt; \n  as.data.frame()\n\n## Displaying the table\ndatatable(wdi_summary_gdp, options = list(pageLength = 10))\n\n\n\n\n\n\n\n\n\nAt this part, we are aggregating the following key socioeconomic variables: life expectancy, GDP, and poverty rates - adjusting for population size to ensure that statistics are representative of regional weights - and reshaping the data for comparability across estimates.\n\n## Data to be replicated\ndesired_output2 &lt;- get_data(rds_file = 'wdi_agg_out.Rds') |&gt; \n  arrange(estimate, region, date, lifeex)\n\n## Replicating the aggregate results\n# Selecting the cols of interest for aggregatin'\nagg_cols &lt;- c(\"lifeex\", \"gdp\", \"povintl\")\n\n## Computing the agg stats\n# 1st agg: population\nagg_pop &lt;- wdi_data |&gt;\n  filter(!is.na(gdp)) |&gt; \n  group_by(region, date) |&gt; \n  summarize(pop = sum(pop))\n\n# 2nd agg: lifeex, gdp and pov_intl variables + 1st agg (merging at the end)\nwdi_agg_stats &lt;- wdi_data |&gt;\n  filter(!is.na(gdp)) |&gt; \n  select(region, date, pop, lifeex, gdp, pov_intl) |&gt; \n  rename_with(~ gsub(\"_\", \"\", .x)) |&gt; \n  group_by(region, date) |&gt; \n  summarize(across(all_of(agg_cols),\n                   list(max = max,\n                        min = min,\n                        median = median,\n                        mean = ~weighted.mean(., pop, na.rm = TRUE),\n                        sd = ~weighted_sd(., pop, na.rm = TRUE)),\n                   .names = \"{.col}_{.fn}\"),\n            .groups = \"drop\") |&gt;\n  pivot_longer(cols = starts_with(agg_cols), \n               names_to = c(\".value\", \"estimate\"), \n               names_sep = \"_\") |&gt; \n  ## Merging the aggregated results with the the info on the population for each region\n  left_join(agg_pop, by = c('region', 'date')) |&gt; \n  select(estimate, region, date, pop, lifeex:povintl) |&gt; \n  arrange(estimate, region, date, lifeex)\n\n## Displaying the table\ndatatable(wdi_agg_stats, options = list(pageLength = 10))"
  },
  {
    "objectID": "basic_stats.html#basic-stats",
    "href": "basic_stats.html#basic-stats",
    "title": "Basic Stats",
    "section": "",
    "text": "Computing summary statistics of the World Development Indicators (WDI) dataset, ‘wdi_data’, which contains socio-economic metrics for various countries over time (in years).\n\n## Loading the data to be computed\nwdi_file &lt;- 'wdi_in1.Rds'\nwdi_data &lt;- get_data(rds_file = wdi_file)\n\n## Data to be replicated\ndesired_output1 &lt;- get_data(rds_file = 'wdi_summ_out.Rds') |&gt; \n  arrange(region, year, N, Mean) |&gt; \n  as.data.frame()\n  \n## Replicating GDP per capita by region\nwdi_summary_gdp &lt;- wdi_data |&gt; \n  mutate(year = as.character(date)) |&gt; \n  select(region, iso3c, year, everything(), -date) |&gt; \n  filter(!is.na(gdp)) |&gt; \n  group_by(region, year) |&gt; \n  summarize(N = as.double(n()),\n            Mean = weighted.mean(gdp, pop, na.rm = TRUE),\n            SD = weighted_sd(gdp, pop, na.rm = TRUE),\n            Min = min(gdp, na.rm = TRUE),\n            Max = max(gdp, na.rm = TRUE)) |&gt; \n  ungroup() |&gt;\n  arrange(region, year, N, Mean) |&gt; \n  as.data.frame()\n\n## Displaying the table\ndatatable(wdi_summary_gdp, options = list(pageLength = 10))\n\n\n\n\n\n\n\n\n\nAt this part, we are aggregating the following key socioeconomic variables: life expectancy, GDP, and poverty rates - adjusting for population size to ensure that statistics are representative of regional weights - and reshaping the data for comparability across estimates.\n\n## Data to be replicated\ndesired_output2 &lt;- get_data(rds_file = 'wdi_agg_out.Rds') |&gt; \n  arrange(estimate, region, date, lifeex)\n\n## Replicating the aggregate results\n# Selecting the cols of interest for aggregatin'\nagg_cols &lt;- c(\"lifeex\", \"gdp\", \"povintl\")\n\n## Computing the agg stats\n# 1st agg: population\nagg_pop &lt;- wdi_data |&gt;\n  filter(!is.na(gdp)) |&gt; \n  group_by(region, date) |&gt; \n  summarize(pop = sum(pop))\n\n# 2nd agg: lifeex, gdp and pov_intl variables + 1st agg (merging at the end)\nwdi_agg_stats &lt;- wdi_data |&gt;\n  filter(!is.na(gdp)) |&gt; \n  select(region, date, pop, lifeex, gdp, pov_intl) |&gt; \n  rename_with(~ gsub(\"_\", \"\", .x)) |&gt; \n  group_by(region, date) |&gt; \n  summarize(across(all_of(agg_cols),\n                   list(max = max,\n                        min = min,\n                        median = median,\n                        mean = ~weighted.mean(., pop, na.rm = TRUE),\n                        sd = ~weighted_sd(., pop, na.rm = TRUE)),\n                   .names = \"{.col}_{.fn}\"),\n            .groups = \"drop\") |&gt;\n  pivot_longer(cols = starts_with(agg_cols), \n               names_to = c(\".value\", \"estimate\"), \n               names_sep = \"_\") |&gt; \n  ## Merging the aggregated results with the the info on the population for each region\n  left_join(agg_pop, by = c('region', 'date')) |&gt; \n  select(estimate, region, date, pop, lifeex:povintl) |&gt; \n  arrange(estimate, region, date, lifeex)\n\n## Displaying the table\ndatatable(wdi_agg_stats, options = list(pageLength = 10))"
  },
  {
    "objectID": "basic_stats.html#q3---finding-outliers",
    "href": "basic_stats.html#q3---finding-outliers",
    "title": "Basic Stats",
    "section": "Q3 - Finding Outliers",
    "text": "Q3 - Finding Outliers\n\n## Data to be replicated\ndesired_output3 &lt;- get_data(rds_file = 'wdi_outliers_out.Rds')\ncols_to_compute &lt;- c('lifeex', 'gdp', 'gini')\n\n## Finding the outliers\n# Step 1: get the mean and sd for the variables of interest for the whole world at every given year\nworld_stats &lt;- wdi_data |&gt;\n  group_by(date) |&gt; \n  summarize(across(all_of(cols_to_compute),\n                   list(mean = ~weighted.mean(., pop, na.rm = TRUE),\n                        sd = ~weighted_sd(., pop, na.rm = TRUE)),\n                   .names = \"{.fn}_{.col}\"))\n\n# Step 2: merge the world stats with `wdi_data`\noutliers_data &lt;- wdi_data |&gt; \n  left_join(world_stats, by = 'date')\n\n# Step 3: calculate the outliers and their respective flags\noutliers_data_final &lt;- outliers_data |&gt; \n  mutate(hl_lifeex = lifeex &gt; (mean_lifeex + (2.5 * sd_lifeex)),\n         ll_lifeex = lifeex &lt; (mean_lifeex - (2.5 * sd_lifeex)),\n         hl_gdp = gdp &gt; (mean_gdp + (2.5 * sd_gdp)),\n         ll_gdp = gdp &lt; (mean_gdp - (2.5 * sd_gdp)),\n         hl_gini = gini &gt; (mean_gini + (2.5 * sd_gini)),\n         ll_gini = gini &lt; (mean_gini - (2.5 * sd_gini))) |&gt; \n  select(colnames(desired_output3))\n\n## Displaying the table\ndatatable(outliers_data_final, options = list(pageLength = 10))\n\n\n\n\n\n# Step 4: reproduce the graph\noutliers_graph &lt;- outliers_data_final |&gt; \n  ggplot(aes(x = date, y = mean_lifeex)) +\n  theme_minimal() +\n  geom_ribbon(aes(ymin = (mean_lifeex + 2.5 * sd_lifeex),\n                  ymax = (mean_lifeex - 2.5 * sd_lifeex)), \n              fill = \"grey\", alpha = 0.50) +\n  geom_line(data = world_stats, aes(x = date, y = mean_lifeex), color = \"blue\", linewidth = .50) +\n  geom_point(aes(x = date, y = lifeex, color = region), position = position_dodge(width = 0.1)) +\n  theme(legend.position = c(0.5, 0.20),\n        legend.justification = \"center\",\n        legend.background = element_blank(), \n        legend.margin = margin(6, 6, 6, 6)) +\n  guides(color = guide_legend(ncol = 4))\n\n## Displaying the graph\noutliers_graph"
  }
]